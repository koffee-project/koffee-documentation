\documentclass[a4paper, 11pt]{article}

\usepackage[%
backend=biber,
sorting=none,
natbib=true,
style=numeric,
autocite=inline
]{biblatex}
\addbibresource{references.bib}

\defbibenvironment{sources}
{\list
	{}
	{\setlength{\leftmargin}{\bibhang}%
		\setlength{\itemindent}{-\leftmargin}%
		\setlength{\itemsep}{\bibitemsep}%
		\setlength{\parsep}{\bibparsep}}}
{\endlist}
{\item}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\sectionmark}[1]{\markboth{#1}{}}
\fancyhead[ER]{\rightmark}
\fancyhead[OL]{\nouppercase{\leftmark}}
\cfoot{\thepage}

\usepackage{float}
\newfloat{lstfloat}{htb}{lop}

\usepackage[ngerman]{isodate, babel}

\usepackage{lmodern}

\usepackage{hyperref}
\addto\extrasngerman{
	\renewcommand{\sectionautorefname}{Kapitel}
	\renewcommand{\subsectionautorefname}{Abschnitt}
	\renewcommand{\subsubsectionautorefname}{Unterabschnitt}
}

\usepackage{graphicx}
\usepackage{caption}
\captionsetup[figure]{width=10cm}

\usepackage{ragged2e}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\overfullrule=1mm

%opening
\title{Dokumentation zur Projektarbeit digitale Kaffeekasse}
\author{Jan Müller}
\date{\today}

\begin{document}

\maketitle

\section{Einleitung}
\label{sec:intro}
Die Entwicklung von Android Apps zeichnet sich unter anderem dadurch aus, dass die \textit{API Level}\footnote{Zum Zeitpunkt dieser Ausarbeitung existieren 29 API Level.} des \textit{Android Frameworks} zum Teil unterschiedlich behandelt werden müssen.
Die Versionsverteilung bei Android erstreckt sich über mehrere Versionen \autocite{androidhistory}.
Zur Maximierung der potenziellen Nutzer ist es entsprechend notwendig auch ältere API Level zu unterstützen.
Damit Entwickler dort ebenfalls neue Funktionen verwenden können, wurden die \textit{Support Libraries} eingeführt \autocite{supportlibraries}.
Aus diesen entwickelten sich die \textit{Android Jetpack} Bibliotheken \autocite{androidjetpack}.

Ziel dieses Projektes war die Entwicklung einer Kaffeekassen App und einer dazugehörigen Serveranwendung mit der Programmiersprache Kotlin.
Für die Entwicklung der App sollten Android Jetpack Bibliotheken verwendet werden um ihre Vorzüge und Eigenschaften kennenzulernen.

Diese Dokumentation stellt Architektur, verwendete Bibliotheken und Eigenschaften der digitalen Kaffeekassen App sowie des zugehörigen Servers vor.
Anschließend wird der Entstehungsprozess beider Programme erläutert und die Projektarbeit zusammengefasst.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Android App}
\label{sec:app}

Kern dieser Projektarbeit ist die Android App, die als Benutzeroberfläche der digitalen Kaffeekasse dient.
Sie basiert auf Grundlagen, welche durch Android Jetpack gelegt wurden.
In diesem Kapitel werden Architektur und verwendete Bibliotheken vorgestellt.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Architektur}
\label{subsec:app:architecture}

Die App verwendet die von Google empfohlene \textit{Model-View-ViewModel} Architektur (\textit{MVVM}) \autocite{androidarchitecture}.
Bei dieser wird die Anwendung in Datenmodell, Benutzeroberfläche und die sogenannten \textit{ViewModels} aufgeteilt (siehe \autoref{fig:app:architecture:mvvm}).

Die Ebene des Datenmodells liegt in Form von \textit{Repositories} vor.
Diese kommunizieren über eine Netzwerkschnittstelle mit der Serveranwendung um Daten zu laden oder Aktionen wie Käufe und Logins durchzuführen.
Darüber hinaus verwalten Repositories lokale Datenbanken, wodurch eine Persistenz ermöglicht wird und Daten bereits vor Antworten der Serveranwendung vorhanden sind.
Weil der Zustand eines Datenmodells ausschließlich vom zugehörigen Repository bestimmt wird, werden sie auch als \textit{Single source of truth} bezeichnet.
Durch diese Eigenschaft ist es möglich inkonsistente Datenbestände zu verhindern.

ViewModels passen von Repositories bereitgestellte Daten für Benutzeroberflächen an und stellen sie in Datencontainern bereit.
Sie selbst haben keine Informationen über Benutzeroberflächen.
Stattdessen beobachten diese Datencontainer der ViewModels und entscheiden selbst wie Daten anzuzeigen sind.

\begin{figure}[H]
	\centering
	\includegraphics[height=8cm,keepaspectratio]{./images/android-architecture.png}
	\caption{MVVM-Entwurfsmuster in Android}
	\caption*{\small Quelle: \url{https://developer.android.com/topic/libraries/architecture/images/final-architecture.png}}
	\label{fig:app:architecture:mvvm}
\end{figure}

%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Android Jetpack}
\label{subsec:app:jetpack}
Im Folgenden werden die verwendeten Android Jetpack Bibliotheken kurz vorgestellt. Detaillierte Informationen können der offiziellen Dokumentation entnommen werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Core und AppCompat}
\label{subsubsec:app:jetpack:base}
Die \textit{Core} und \textit{AppCompat} Bibliotheken ermöglichen eine Verwendung von Funktionen neuer Android API Levels auf älteren Android Versionen.
Dazu stellen sie eine Vielzahl an Hilfsklassen zur Verfügung, welche die unterschiedliche Behandlung der API Levels verkapseln und die Entwicklung so vereinheitlichen und vereinfachen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Fragment}
\label{subsubsec:app:jetpack:fragment}
Fragmente sind modulare Teile einer Benutzeroberfläche.
Sie sind wiederverwendbar, leichtgewichtig und lassen sich in \textit{Activities} sowie anderen Fragmenten kombinieren um komplexe Benutzeroberflächen zu erstellen.
Ihr Lebenszyklus wird von ihrem Container verwaltet, weshalb sie sich für Entwickler nur gering von Activities unterscheiden.
Darüber hinaus ist es möglich Fragmente dynamisch hinzuzufügen und zu entfernen.
Komplexe \textit{Layouts} lassen sich so in mehrere Fragmente unterteilen, welche unabhängig voneinander wiederverwendbar sind.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Databinding}
\label{subsubsec:app:jetpack:databinding}
Mit Hilfe der \textit{Databinding} Bibliothek ist es möglich Datenquellen für Eigenschaften von Benutzeroberflächen und deren Elemente in Layout-Dateien festzulegen.
In Kombination mit \textit{LiveData} passen sich Benutzeroberflächen bei Änderungen automatisch an, wodurch der Anteil an Quelltext für Benutzeroberflächen reduziert wird.
Zusätzlich lassen sich \textit{BindingAdapters} definieren, durch welche benutzerdefiniertes Verhalten und eine Definition neuer Eigenschaften möglich wird.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Lifecycle}
\label{subsubsec:app:jetpack:lifecycle}
Die \textit{Lifecycle} Bibliothek umfasst primär ViewModels und LiveData.
Bei ViewModels handelt es sich um Klassen, die von Fragmenten zur Darstellung von Daten und Interaktion mit Business Logic verwendet werden.
Ihre Erzeugung wird von Framework-Methoden übernommen.
Diese stellen sicher, dass ViewModels sich dem Lebenszyklus des besitzenden Fragments anpassen und wiederverwendet werden können.

LiveData baut auf diesem Konzept auf.
Dabei handelt es sich um \textit{Wrapper} für beliebige Daten, deren Werte beobachtet werden können.
Anders als traditionelle \textit{Observables} besitzt LiveData jedoch einen Lebenszyklus.
Änderungen werden nur dann propagiert, wenn sie auch beobachtet.
Zudem übernimmt das besitzende ViewModel die Verwaltung ihres Lebenszyklus, wodurch \textit{Leaks} vermieden werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Navigation}
\label{subsubsec:app:jetpack:navigation}
Fragmente können mit Argumenten erzeugt werden.
Dabei ist jedoch keine Typsicherheit garantiert und es gibt keinen Mechanismus, der die Vollständigkeit von Argumenten sicherstellt.
Die \textit{Navigation} Bibliothek löst beide Probleme durch Verwendung von Navigationsgraphen.
In diesen werden die verfügbaren Fragmente sowie ihre Argumente definiert.
Durch Verbindungen zwischen Fragmenten werden \textit{Directions} angegeben.
Deren Verwendung stellst sicher, dass alle Argumente mit korrektem Typ festgelegt wurden und Navigation nur zu korrekten Fragmenten möglich ist.
Darüber hinaus unterstützt die Bibliothek Navigationscontroller, die das Initialisieren von Benutzerelemente wie beispielsweise einer \textit{Bottom Navigation} übernehmen. 
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{ConstraintLayout und SwiperefreshLayout}
\label{subsubsec:app:jetpack:layouts}
Android Jetpack umfasst auch mehrere Layout Bibliotheken.
Im Rahmen dieses Projektes wurden \textit{ConstraintLayout} und \textit{SwiperefreshLayout} verwendet.

Komplexe Hierarchien in Benutzeroberflächen verringern deren Performanz bei Layoutänderungen.
ConstraintLayouts ermöglichen das freie Platzieren von Elementen durch Einschränkungen ihrer Positionen.
So können Entwickler simplere und effizientere Layouts implementieren.

Bei mobilen Anwendungen gibts es die gängige Geste des Herunterziehens zum Aktualisieren eines Bildschirms.
Mit Hilfe von SwiperefreshLayout ist es möglich diese Funktionalität mit wenigen Zeilen Quelltext zu bestehenden Benutzeroberflächen hinzuzufügen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{RecyclerView}
\label{subsubsec:app:jetpack:recyclerview}
\textit{RecyclerViews} ermöglichen das Anzeigen von scrollbaren, dynamischen Listen.
Anders als primitive \textit{Views} erzeugt RecyclerView nur die tatsächlich benötigten Container und verwendet diese wieder.
Dies ist performanter als beispielsweise eine \textit{ListView}.
Entwickler müssen Adapter verwenden um Daten an eine RecyclerView zu übergeben.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Room}
\label{subsubsec:app:jetpack:room}
Bei \textit{Room} handelt es sich um eine Abstraktionsebene für \textit{SQLite} Datenbanken.
Es können sowohl programmatische als auch reguläre SQL Anfragen definiert werden.
Die Hauptfunktion von Room liegt jedoch in der Möglichkeit Rückgabewerte in reaktiven Wrapper-Klassen, wie beispielsweise LiveData, zu erhalten.
Room übernimmt in diesem Fall die Aktualisierung der Daten, wodurch es reicht Datenbankanfragen einmalig auszuführen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Paging}
\label{subsubsec:app:jetpack:paging}
Das Laden großer Datenmengen aus Datenbanken oder Netzwerkquellen ist ein nicht zu unterschätzender Aufwand.
Die \textit{Paging} Bibliothek ermöglicht deshalb das Laden von kleinen Teilen größerer Datensätze.
Dazu muss eine \textit{DataSource Factory} vorliegen, die das stückweise Laden von Daten unterstützt.
Unter anderem ermöglicht Room solche Factories als Rückgabewerte zu erhalten.
Factories lassen sich zu LiveData Objekten transformieren, die \textit{PagedLists} enthalten.
Diese besonderen Listen können beispielsweise von für RecyclerView mit Hilfe eines \textit{PagedListAdapters} verwendet werden.
Im Endeffekt können so Performanz und Speicherverbrauch verbessert werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Work}
\label{subsubsec:app:jetpack:work}
Hintergrundaufgaben, wie beispielsweise das Bereinigen von Datenbanken, können über die \textit{Work} Bibliothek verwaltet werden.
Die zu erledigende Arbeit wird dabei in einer \textit{Worker} Klasse definiert.
Bei der Registrierung können optional Einschränkungen angegeben werden, die festlegen wann und unter welchen Umständen der Worker ausgeführt wird.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{KTX}
\label{subsubsec:app:jetpack:extensions}
Kotlin ist bereits die von Google empfohlene Sprache für die Entwicklung von Android Apps \autocite{androidkotlin}.
Eine Vielzahl an Android Jetpack Bibliotheken enthalten Kotlin spezifische Erweiterungsmethoden und Sprachfunktionen, welche die Programmierung von Android Apps vereinfachen und verbessern.
Dazu zählen unter anderem Methoden zum Erzeugen von ViewModels und \textit{Coroutine Scopes} für ViewModels, Erweiterungen für \textit{SharedPreferences} sowie Unterstützung für \textit{Coroutines} in Android Jetpack Bibliotheken.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Weitere Bibliotheken}
\label{subsec:app:bibs}

Im Rahmen der App-Entwicklung wurden auch Bibliotheken verwendet, welche nicht Teil von Android Jetpack sind.
Im Folgenden werden ihre Funktionen und Verwendungsgründe vorgestellt.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Retrofit und Moshi}
\label{subsubsec:app:bibs:retrofitmoshi}

Über \textit{Retrofit} können abstrakte Methoden zum Verwenden von APIs definiert werden.
Entwickler müssen dazu Informationen über die Art von Anfragen angeben.
Implementierungen dieser Methoden werden von der Bibliothek generiert.
In Kombination mit der Serialisierungs-Bibliothek \textit{Moshi} können so Netzwerkschnittstellen mit geringem Quelltextaufwand angebunden werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Glide}
\label{subsubsec:app:bibs:glide}

\textit{Glide} übernimmt das asynchrone Laden und Darstellen von Bildern.
Dabei lassen sich Einstellungen für Verhalten und Darstellung anpassen.
Unter anderem kann Glide Bilder für schnelleres Laden zwischenspeichern, zuschneiden und während einem Ladevorgang durch Platzhalter ersetzen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Image Picker}
\label{subsubsec:app:bibs:imagepicker}

Die Bibliothek \textit{Image Picker} ermöglicht die Auswahl von Bildern zur Laufzeit, die Nutzer entweder aus ihrer Galerie auswählen oder mit ihrer Kamera aufnehmen können.
Eine äquivalente Funktionalität zu implementieren ist mit nicht-trivialem Aufwand verbunden, weshalb eine Verwendung existierender Bibliotheken die Entwicklung verkürzte.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{PrettyTime}
\label{subsubsec:app:bibs:prettytime}

\textit{PrettyTime} wird verwendet um Zeitstempel in ein für Menschen lesbares Format zu transformieren.
Die Bibliothek unterstützt mehrere Sprachen, unter anderem Deutsch sowie Englisch, und erspart Entwicklern so das Übersetzen und Formatieren.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Timber}
\label{subsubsec:app:bibs:timber}

Bei \textit{Timber} handelt es sich um eine Bibliothek die das Protokollieren vereinfacht, Nachrichten mit zusätzlichen Informationen wie beispielsweise ihrem Ursprung ausgibt und jegliche Protokollierung außerhalb der Entwicklungsphase deaktiviert.
So ist es während der Entwicklung möglich schnell detaillierte Protokollnachrichten zu verfassen, die keine Auswirkung auf ausgelieferte Endprodukte haben und bei der Suche nach Fehlern helfen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Serveranwendung}
\label{sec:backend}

Das Backend wurde, wie auch die App, mit der Programmiersprache Kotlin entwickelt.
Es handelt sich dabei um eine \textit{REST}-Schnittstelle\footnote{Siehe \url{https://restfulapi.net/}.}, die dazu dient den Zustand der digitalen Kaffeekasse zu verwalten.
Die folgenden Abschnitte stellen verwendete Bibliotheken, Architektur, Endpunkte und Authentisierung des Backends vor.
%------------------------------------------------------------------------------------------------------------------------------------------------------ 

\subsection{Architektur}
\label{subsec:backend:architecture}

Das Backend verwendet eine serviceorientierte Architektur.
Dabei werden Anfragen an Dienste weitergeleitet.
Antworten von Diensten enthalten Informationen über Ergebnisse der Aktionen, wie Statuscodes, Daten oder Fehlermeldungen, und werden an Kommunikationspartner weitergeleitet.

Es existieren Dienste für Nutzer-, Profilbild-, Artikel- und Transaktionsverwaltung.
Validierung sowie Fehlerbehandlung finden ausschließlich in Diensten statt.
Dafür verwenden sie einen funktionalen Ansatz und sind selbst zustandslos.

Analog zur Android App liegt die Persistenzebene in Form von Repositories vor.
Die gegebenen Implementierungen der Nutzer-, Profilbild- und Artikel-Repositories fungieren als Schnittstellen zur verwendeten \textit{MongoDB}.

Sowohl Dienste als auch Repositories liegen als \textit{Interfaces} und Implementierungen vor, um separates Testen zu ermöglichen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Authentifizierung}
\label{subsec:backend:authentication}

Um Administrator-Funktionen zu verwenden müssen sich Nutzer authentifizieren.
Dies findet mit Hilfe von \textit{JSON Web Tokens}\footnote{Siehe \url{https://jwt.io/}.}, auch \textit{JWT} genannt, statt.
Ein JWT wird nach einem erfolgreichen Login generiert, ist für 24 Stunden gültig und muss bei jeder Anfrage für Administrator-Funktionen enthalten sein.
Einloggen können sich nur Nutzer, die über Administratorrechte verfügen, welche wiederum nur von Administratoren vergeben werden können.
Während jedem Start generiert das Backend einen Standard\-administrator, welcher zuvor festgelegte Daten besitzt (siehe \autoref{subsec:backend:configuration}).
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Konfiguration}
\label{subsec:backend:configuration}

Um das Backend an Einsatzumgebungen anzupassen können einige Parameter konfiguriert werden.
Dies findet über \verb|.env|-Dateien statt, welche sich in dem \verb|environments|-Ordner des Hauptverzeichnisses befinden.
Dort werden die Adressen von Server und Datenbank sowie Eigenschaften der Zertifizierung festgelegt.
Darüber hinaus werden die Namen der \textit{Docker Secrets}-Dateien angegeben.
In diesen Dateien werden sensible Daten, wie die Informationen des Standardadministrators und der Schlüssel für Signierung von JWTs, hinterlegt.
Detaillierte Informationen zur Syntax dieser Konfigurationsdateien sowie Inbetriebnahme und Wartung des Backends können der \verb|README.md|-Datei entnommen werden, welche dem Projekt beiliegt.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Bibliotheken}
\label{subsec:backend:bibs}

Um die Entwicklung des Backends zu beschleunigen wurden mehrere Open Source Bibliotheken verwendet.
Diese werden im Folgenden kurz vorgestellt.
Zusätzliche Informationen können den jeweiligen Projektseiten entnommen werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Ktor}
\label{subsubsec:backend:bibs:ktor}

\textit{Ktor}, ein \textit{Web Framework} vom Entwickler der Sprache Kotlin, bildet die Grundlage des Backends.
Ktor verwendet eine \textit{Domain Specific Language}, auch \textit{DSL} genannt, zum Definieren von Modulen.
Solche Module können in der Serveranwendung installiert werden um ein erwünschtes Verhalten zu erreichen.
Ktor selbst stellt dabei Module für verschiedene Bereiche, wie unter anderem Protokollierung, Serialisierung und Authentisierung, zur Verfügung.
Auch vordefinierte Module können im Quelltext angepasst werden.
Ktor zeichnet sich zudem dadurch aus, dass es vollständig asynchron arbeitet und Kotlin Coroutines an allen Stellen der Konfiguration verwendbar sind.
Dadurch können Entwickler asynchronen und performanten Quelltext schreiben ohne zusätzliche Sprachkonstrukte zu verwenden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Koin}
\label{subsubsec:backend:bibs:koin}

\textit{Koin} ist ein Framework für \textit{Dependency Injection}, mit dem einzelne Komponenten des Servers unabhängig von ihrem Einsatzort initialisiert werden können.
So ist es möglich Instanzen von Diensten sowie Repositories wiederzuverwenden und den für Instanziierung benötigten Quelltext zu minimieren.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{KMongo}
\label{subsubsec:backend:bibs:kmongo}

Die \textit{KMongo} Bibliothek ermöglicht eine simple Verwendung von \textit{Mongo}-Datenbanken in Kotlin.
Dies erreicht sie durch automatische Serialisierung, Unterstütztung für Kotlin Coroutines und programmatische, typsichere Anfragen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{jBCrypt}
\label{subsubsec:backend:bibs:jbcrypt}

Das Backend muss Passwörter sicher in der Datenbank ablegen.
Dafür müssen diese durch eine geeignete \textit{Hash}-Funktion transformiert werden.
Die Bibliothek \textit{jBCrypt} enthält solche Funktionen.
Darüber hinaus ermöglicht sie auch das anschließende Überprüfen von Passwörtern.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Arkenv}
\label{subsubsec:backend:bibs:arkenv}

Zur Konfiguration des Backends an eine Einsatzumgebung müssen einige Parameter, wie der Datenbankhost, gesetzt werden.
\textit{Arkenv} erlaubt es diese Umgebungsvariablen programmatisch und typsicher zu definieren, so dass die Fehleranfälligkeit beim Einlesen reduziert wird.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Docker Secrets}
\label{subsubsec:backend:bibs:dockersecrets}

Neben Umgebungsvariablen müssen auch sensible Daten, wie die Zugangsinformationen des Standardadministrators, festgelegt werden.
Um diese zu schützen werden beim \textit{Deployment} des Backends mit Docker sogenannte \textit{Secrets} verwendet, welche nur das Backend selbst einsehen kann.
Da es sich dabei um Dateien handelt ist das Einlesen ihrer Informationen mit einer Syntaxanalyse verbunden.
Die leichtgewichtige Bibliothek Docker Secrets übernimmt diesen Aufwand und lädt Parameter von Dateien in \textit{Maps}.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Vorgehen und Entstehungsprozess}
\label{sec:methodologies}

Die Projektarbeit begann mit der Entwicklung des Backends.
Zunächst wurden Aufbau sowie Struktur festgelegt und implementiert um eine Arbeitsgrundlage zu schaffen.
Dank der modularen Zusammensetzung des Backends war es möglich die benötigten Endpunkte für Nutzer, Artikel sowie Transaktionen schnell und unabhängig voneinander zu implementieren.
Anschließend wurde die Authentisierung hinzugefügt um Endpunkte vor unautorisierten Zugriffen zu schützen.
Da eine langfristige Nutzung des Backends in Frage kam, wurde der Quelltext nahezu vollständig getestet.
Tests wurden parallel zum eigentlich Programm geschrieben um Fehler schnell zu erkennen.
Im Laufe der Entwicklung wurde das Backend mehrfach überarbeitet um einen möglichst funktionalen Programmierstil zu erreichen.
So konnte die Lesbarkeit verbessert und die Fehleranfälligkeit reduziert werden.
Während der gesamten Projektarbeit wurde zudem die Formatierung des Quelltextes mit dem Tool \textit{klint}\footnote{Siehe \url{https://github.com/pinterest/ktlint}.} kontrolliert und korrigiert.
Darüber hinaus wurden Open Source Bibliotheken verwendet, falls Problemlösungen einen größeren Aufwand erforderten.
Dadurch konnte die Entwicklungszeit verkürzt und auf die eigentliche Aufgabenstellung konzentriert werden.

Die Entwicklung der App begann Ende April.
Analog zu den Endpunkten des Backends wurden die Bildschirme der App nacheinander implementiert, wobei jeweils mehrere Revisionen durchgeführt wurden.
Eine Verwendung der Android Jetpack Bibliotheken erlaubten dabei eine schnelle Entwicklung mit einem geringen Anteil an Boilerplate Code.
Um diesen weiter zu reduzieren wurden im Laufe der Entwicklung häufig auftretende Muster, wie beispielsweise von ViewModels initiierte Aktionen, in Klassen ausgelagert.
Auch bei den ViewModels selbst sowie Fragmenten wurde Vererbung verwendet um oft benötigtes Verhalten nicht mehrfach zu implementieren.
Zudem wurde die Fehlerbehandlung zentralisiert um die Fehlerausgabe zu vereinfachen und Abstürze zu verhindern.
Durch solche Änderungen war es möglich den Quelltext deutlich zu kürzen.
Zunächst wurde die App für einen Nutzer pro Endgerät entwickelt.
Anfang Juni wurde, nach Anfrage des Projektbetreuers, ein zusätzlicher Modus für mehrere Nutzer implementiert.
Weil die einzelnen Komponenten der App bereits modular und wiederverwendbar waren, konnte diese größere Änderung schnell umgesetzt werden. 
Im Anschluss wurden ein Großteil der Benutzeroberflächen sowie deren Verwendung überarbeitet und verbessert.

Nachdem die Funktionalität beider Teilprojekte vollständig implementiert war, wurde mit der Dokumentation des Quelltextes begonnen, welche im Internet abrufbar ist\footnote{Siehe \url{http://koffee-app.yeger.eu/} und \url{http://koffee-backend.yeger.eu/}.}.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Fazit}
\label{sec:conclusion}
%TODO italics
Die Verwendung von Android Jetpack Bibliotheken im Zusammenspiel mit Kotlin vereinfacht die Entwicklung robuster und performanter Android Apps deutlich.
Besonders die automatisierten Lebenszyklen von ViewModel und LiveData helfen bei der Vermeidung Leaks.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\newpage
\begingroup
\raggedright
\printbibliography[title={Referenzen}, keyword=citations]
\nocite{*}
\newrefcontext[sorting=nty]
\printbibliography[title={Dokumentation}, keyword=sources, env=sources]
\endgroup

\end{document}
