\documentclass[a4paper, 11pt]{article}

\usepackage[%
backend=biber,
sorting=none,
natbib=true,
style=numeric,
autocite=inline
]{biblatex}
\addbibresource{references.bib}

\usepackage{booktabs}
\usepackage{listings}
\lstdefinestyle{simpleListing}{
	language=Bash,
	numbers=left,
	numbersep=10pt,
	numberstyle = \tiny,
	tabsize=4,
	showspaces=false,
	showstringspaces=false,
	basicstyle=\small\ttfamily,
	breaklines=true,
	xleftmargin=0.1\textwidth,
	captionpos=b,
}

\defbibenvironment{sources}
{\list
	{}
	{\setlength{\leftmargin}{\bibhang}%
		\setlength{\itemindent}{-\leftmargin}%
		\setlength{\itemsep}{\bibitemsep}%
		\setlength{\parsep}{\bibparsep}}}
{\endlist}
{\item}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\sectionmark}[1]{\markboth{#1}{}}
\fancyhead[ER]{\rightmark}
\fancyhead[OL]{\nouppercase{\leftmark}}
\cfoot{\thepage}

\usepackage{float}
\newfloat{lstfloat}{htb}{lop}

\usepackage[ngerman]{isodate, babel}

\usepackage{lmodern}

\usepackage{hyperref}
\addto\extrasngerman{
	\renewcommand{\sectionautorefname}{Kapitel}
	\renewcommand{\subsectionautorefname}{Abschnitt}
	\renewcommand{\subsubsectionautorefname}{Unterabschnitt}
}

\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\captionsetup[figure]{width=10cm}

\usepackage{ragged2e}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\overfullrule=1mm

%opening
\title{Dokumentation zur Projektarbeit digitale Kaffeekasse}
\author{Jan Müller}
\date{\today}

\begin{document}

\maketitle

\section{Einleitung}
\label{sec:intro}
Die Entwicklung von Android Apps zeichnet sich unter anderem dadurch aus, dass die \textit{API Level}\footnote{Zum Zeitpunkt dieser Ausarbeitung existieren 29 API Level.} des \textit{Android Frameworks} unterschiedliche Funktionalitäten bereitstellen.
Die Nutzerverteilung erstreckt sich über mehrere Versionen \autocite{androidhistory}.
Zur Maximierung der potenziellen Nutzer ist es entsprechend notwendig auch ältere API Level zu unterstützen.
Damit Entwickler dort ebenfalls neue Funktionen verwenden können, wurden die \textit{Support Libraries} eingeführt \autocite{supportlibraries}.
Aus diesen entwickelten sich die \textit{Android Jetpack} Bibliotheken \autocite{androidjetpack}.

Ziel dieses Projektes war die Entwicklung einer Kaffeekassen App und einer dazugehörigen Serveranwendung mit der Programmiersprache Kotlin.
Für die Entwicklung der App sollten Android Jetpack Bibliotheken verwendet werden, um ihre Vorzüge und Eigenschaften kennenzulernen.

Diese Dokumentation stellt Architektur, verwendete Bibliotheken und Eigenschaften der digitalen Kaffeekassen App sowie des zugehörigen Servers vor.
Anschließend wird der Entstehungsprozess beider Programme erläutert und ein Fazit zu Android Jetpack gezogen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Android App}
\label{sec:app}
Kern dieser Projektarbeit ist die Android App, die als Benutzeroberfläche der digitalen Kaffeekasse dient.
Sie basiert auf Grundlagen, welche durch Android Jetpack gelegt wurden.
In diesem Kapitel werden Funktionalität, Architektur, verwendete Android Jetpack Komponenten und Bibliotheken sowie Konfiguration der App vorgestellt.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Funktionalität}
\label{subsec:app:functionality}
Beim erstmaligen Starten der App werden Nutzer gebeten ihren Account auszuwählen.
Alternativ können sie den Modus für eine geteilte Verwendung starten, welcher später erläutert wird.
Der zugehörige Dialog ist in \autoref{fig:app:architecture:functionality:selection:dialog} zu sehen.
\begin{figure}[]
	\begin{subfigure}{.5\textwidth}
		\centering
			\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/greetings-dialog.png}
		\caption{Begrüßungsdialog}
		\label{fig:app:architecture:functionality:selection:dialog}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/user-search.png}
		\caption{Nutzerauswahl und -suche}
		\label{fig:app:architecture:functionality:selection:search}
	\end{subfigure}
	\caption{Begrüßungsdialog und Nutzerauswahl}
	\label{fig:app:architecture:functionality:selection}
\end{figure}
Die Nutzerauswahl zeigt eine Liste aller existieren Nutzer an und ermöglicht es diese Interaktiv zu filtern.
Suchergebnisse werden unmittelbar angezeigt und benötigen keine zusätzlichen Eingaben (siehe \autoref{fig:app:architecture:functionality:selection:search}).
Nachdem ein Nutzer durch Klicken ausgewählt wurde öffnet sich die Hauptseite der App.
Dort werden Informationen des ausgewählten Nutzers, falls vorhanden seine letzte Transaktion und verfügbare Artikel angezeigt.
Auch diese lassen sich analog zu Nutzern filtern und durch klicken auswählen, wie in \autoref{fig:app:architecture:functionality:home:search} sichtbar.
Falls eine stornierbare Transaktion vorliegt wird diese ebenfalls hier angezeigt (siehe \autoref{fig:app:architecture:functionality:home:transaction}).
Durch Klicken auf das Profilbild beziehungsweise dessen Platzhalter kann dieses bearbeitet oder entfernt werden.
\begin{figure}[]
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/home-fragment.png}
		\caption{Artikelsuche}
		\label{fig:app:architecture:functionality:home:search}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/home-fragment-transaction.png}
		\caption{Stornierbare Transaktion}
		\label{fig:app:architecture:functionality:home:transaction}
	\end{subfigure}
	\caption{Hauptbildschirm}
	\label{fig:app:architecture:functionality:home}
\end{figure}

Die Artikelseite zeigt neben Preis und Name des Artikels auch alle Transaktionen des aktiven Nutzers an, die zu diesem Artikel gehören.
Falls es sich um einen Artikel mit begrenztem Bestand handelt wird auch dieser angezeigt und bei Transaktionen aktualisiert.
Zudem können Stornierungen auch von der Seite des betroffenen Artikels durchgeführt werden, wie in \autoref{fig:app:architecture:functionality:item} zu sehen ist.
Wie auch beim Hauptbildschirm ist die Option nur während des gültigen Zeitrahmens von 60 Sekunden verfügbar und verschwindet nach Ablaufen der Zeit selbstständig.
\begin{figure}[]
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/item-purchased.png}
		\caption{Gekaufter Artikel}
		\label{fig:app:architecture:functionality:item:purchase}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/item-refunded.png}
		\caption{Stornierte Transaktion}
		\label{fig:app:architecture:functionality:item:refund}
	\end{subfigure}
	\caption{Artikelbildschirm}
	\label{fig:app:architecture:functionality:item}
\end{figure}

Eine Übersicht über alle Transaktionen können sich Nutzer mit der Historie verschaffen.
Diese ist wie auch die Haupt-, Statistik- und die Einstellungsseiten über die Navigationsleiste erreichbar (siehe \autoref{fig:app:architecture:functionality:history:navigation}).
Die Historie zeigt eine vollständige Liste aller Transaktionen, die der ausgewählte Nutzer getätigt hat.
Sie sind nach Transaktionszeitpunkten sortiert und geben Art, Wert und weitere Details der Transaktion an, wie in \autoref{fig:app:architecture:functionality:history:history} abgebildet ist.
Durch Klicken auf Käufe oder Stornierungen wird zur Seite des zugehörigen Artikels navigiert.
Wie bei allen Bildschirmen dieser App ist es zudem möglich die Seite durch eine \textit{Swipe-to-Refresh}-Geste zu aktualisieren.
\begin{figure}[]
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/navigation.png}
		\caption{Navigation}
		\label{fig:app:architecture:functionality:history:navigation}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/history.png}
		\caption{Historie}
		\label{fig:app:architecture:functionality:history:history}
	\end{subfigure}
	\caption{Navigation und Historie}
	\label{fig:app:architecture:functionality:history}
\end{figure}

Auf der Statistikseite finden sich Angaben zu Anzahl und letzten Kaufzeitpunkten pro Artikel vom aktiven Nutzer (siehe \autoref{fig:app:architecture:functionality:various:statistics}).
Auch hier ist es möglich durch Klicken auf einen Eintrag zur Seite des zugehörigen Artikels zu navigieren.

Die Einstellungen umfassen neben Optionen zur erneuten Nutzerauswahl und Starten des geteilten Modus auch die Administrator-Funktionen (siehe \autoref{fig:app:architecture:functionality:various:settings} und \autoref{fig:app:architecture:functionality:various:adminfunctions}).
Diese sind jedoch erst nach einem Login zugänglich, welcher über die in \autoref{fig:app:architecture:functionality:various:login} gezeigte Seite stattfindet.
\begin{figure}[]
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/statistics.png}
		\caption{Statistiken}
		\label{fig:app:architecture:functionality:various:statistics}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/settings.png}
		\caption{Einstellungen}
		\label{fig:app:architecture:functionality:various:settings}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/login.png}
		\caption{Login}
		\label{fig:app:architecture:functionality:various:login}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/settings-admin.png}
		\caption{Administrator-Funktionen}
		\label{fig:app:architecture:functionality:various:adminfunctions}
	\end{subfigure}
	\caption{Verschiedene Bildschirme}
	\label{fig:app:architecture:functionality:various}
\end{figure}

Die Buttons \textit{MANAGE USERS} und \textit{MANAGE ITEMS} öffnen Seiten, welche respektiv denen der Nutzer- und Artikelauswahl entsprechen.
Sie verfügen jedoch über zusätzliche Buttons, die Seiten zum Erstellen neuer Nutzer beziehungsweise Artikel öffnen.
\autoref{fig:app:architecture:functionality:admin:create} zeigt diese Nutzervariante dieser Seite.
Felder, welche als optional markiert sind müssen nicht ausgefüllt werden.
IDs können beispielsweise von der Serveranwendung vergeben werden.
Um einen Nutzer oder Artikel zu bearbeiten muss auf diesen geklickt werden.
Während sich bei Artikel eine erweiterte Ansicht der Artikelseite öffnet haben Administratoren eine besondere Ansicht für Nutzer (siehe \autoref{fig:app:architecture:functionality:admin:user}).
Dort sehen sie alle Transaktionen von Nutzern, können Profilbildern bearbeiten sowie löschen und haben die Möglichkeit Guthaben aufzuladen.
Sowohl bei Nutzern als auch bei Artikeln gibt es Optionen zum Löschen und Bearbeiten der gesamten Entität.
Bearbeitungsseiten entsprechen vom Aufbau her den Seiten zum Erstellen, wie in \autoref{fig:app:architecture:functionality:admin:edit} zu sehen ist.
Beim Löschen müssen zwei Dialoge bestätigt werden, um sicherzustellen, dass die Aktion bewusst stattfindet.
%TODO crediting erklären
\begin{figure}[]
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/create-user.png}
		\caption{Nutzer erstellen}
		\label{fig:app:architecture:functionality:admin:create}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/user-admin-view.png}
		\caption{Administratoransicht}
		\label{fig:app:architecture:functionality:admin:user}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/crediting.png}
		\caption{Guthabenaufladung}
		\label{fig:app:architecture:functionality:admin:crediting}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[height=8cm,keepaspectratio]{./images/screenshots/edit-item.png}
		\caption{Artikel bearbeiten}
		\label{fig:app:architecture:functionality:admin:edit}
	\end{subfigure}
	\caption{Administrator-Funktionen}
	\label{fig:app:architecture:functionality:admin}
\end{figure}

%TODO multi user mode erklären - parallelen zu single user mode und ohne bilder
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Architektur}
\label{subsec:app:architecture}
Die App verwendet die von Google empfohlene \textit{Model-View-ViewModel} Architektur (\textit{MVVM}) \autocite{androidarchitecture}.
Bei dieser wird die Anwendung in Datenmodell, Benutzeroberfläche und die sogenannten \textit{ViewModels} aufgeteilt (siehe \autoref{fig:app:architecture:mvvm}).

Die Ebene des Datenmodells liegt in Form von \textit{Repositories} vor.
Diese kommunizieren über eine Netzwerkschnittstelle mit der Serveranwendung um Daten zu laden oder Aktionen wie Käufe und Logins durchzuführen.
So erhaltene Daten werden unmittelbar in die lokale Datenbank geschrieben und auch nur von dort aus geladen.
Über diesen Mechanismus wird eine lokale Persistenz ermöglicht, wodurch Daten auch ohne Verbindung zum Server angezeigt werden können.
Weil der Zustand eines Datenmodells ausschließlich vom zugehörigen Repository bestimmt wird, werden sie auch als \textit{Single source of truth} bezeichnet.
Durch diese Eigenschaft ist es möglich inkonsistente Datenbestände zu verhindern.

ViewModels passen von Repositories bereitgestellte Daten für Benutzeroberflächen an und stellen sie in Datencontainern bereit.
Sie selbst haben keine Informationen über Benutzeroberflächen.
Stattdessen reagieren diese auf Änderungen an ViewModels und entscheiden selbst über die Datenanzeige.

\begin{figure}[H]
	\centering
	\includegraphics[height=8cm,keepaspectratio]{./images/android-architecture.png}
	\caption{MVVM-Entwurfsmuster in Android}
	\caption*{\small Quelle: \url{https://developer.android.com/topic/libraries/architecture/images/final-architecture.png}}
	\label{fig:app:architecture:mvvm}
\end{figure}
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Android Jetpack}
\label{subsec:app:jetpack}
Im Folgenden werden die verwendeten Android Jetpack Bibliotheken kurz vorgestellt. Detaillierte Informationen können der offiziellen Dokumentation entnommen werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Core und AppCompat}
\label{subsubsec:app:jetpack:base}
Die \textit{Core} und \textit{AppCompat} Bibliotheken ermöglichen eine Verwendung von Funktionen neuer Android API Levels auf älteren Android Versionen.
Dazu stellen sie eine Vielzahl an Hilfsklassen zur Verfügung, welche die unterschiedliche Behandlung der API Levels verkapseln und die Entwicklung so vereinheitlichen und vereinfachen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Fragment}
\label{subsubsec:app:jetpack:fragment}
Fragmente sind modulare Teile einer Benutzeroberfläche.
Sie sind wiederverwendbar, leichtgewichtig und lassen sich in \textit{Activities} sowie anderen Fragmenten kombinieren um komplexe Benutzeroberflächen zu erstellen.
Ihr Lebenszyklus wird von ihrem Container verwaltet, weshalb sie sich für Entwickler nur gering von Activities unterscheiden.
Darüber hinaus ist es möglich Fragmente dynamisch hinzuzufügen und zu entfernen.
Komplexe \textit{Layouts} lassen sich so in mehrere Fragmente unterteilen, welche unabhängig voneinander wiederverwendbar sind.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Databinding}
\label{subsubsec:app:jetpack:databinding}
Mit Hilfe der \textit{Databinding} Bibliothek ist es möglich Datenquellen für Eigenschaften von Benutzeroberflächen und deren Elemente in Layout-Dateien festzulegen.
In Kombination mit \textit{LiveData} passen sich Benutzeroberflächen bei Änderungen automatisch an, wodurch der Anteil an Quelltext für Benutzeroberflächen reduziert wird.
Zusätzlich lassen sich \textit{BindingAdapters} definieren, durch welche benutzerdefiniertes Verhalten und eine Definition neuer Eigenschaften möglich wird.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Lifecycle}
\label{subsubsec:app:jetpack:lifecycle}
Die \textit{Lifecycle} Bibliothek umfasst primär ViewModels und LiveData.
Jetpack ViewModels werden vom Android Framework verwaltet und passen sich dem Lebenszyklus des besitzenden Fragments an.

LiveData baut auf diesem Konzept auf.
Dabei handelt es sich um \textit{Wrapper} für beliebige Daten, deren Werte beobachtet werden können.
Anders als traditionelle \textit{Observables} besitzt LiveData jedoch einen Lebenszyklus.
Änderungen werden nur dann propagiert, wenn sie auch beobachtet werden.
Zudem übernimmt das besitzende ViewModel die Verwaltung ihres Lebenszyklus, wodurch \textit{Memory Leaks} vermieden werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Navigation}
\label{subsubsec:app:jetpack:navigation}
Fragmente können mit Argumenten erzeugt werden.
Dabei ist jedoch keine Typsicherheit garantiert und es gibt keinen Mechanismus, der die Vollständigkeit von Argumenten sicherstellt.
Die \textit{Navigation} Bibliothek löst beide Probleme durch Verwendung von Navigationsgraphen.
In diesen werden verfügbare Fragmente und ihre Argumente definiert.
Durch Verbindungen zwischen Fragmenten werden \textit{Directions} angegeben.
Deren Verwendung bei der Navigation stellt sicher, dass alle Argumente mit korrektem Typ vorhanden sind und zum korrekten Fragment navigiert wird.
Darüber hinaus unterstützt die Bibliothek Navigationscontroller, die das Initialisieren von Benutzerelementen wie \textit{Bottom Navigations} und \textit{Hamburger Menus} übernehmen. 
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{ConstraintLayout und SwiperefreshLayout}
\label{subsubsec:app:jetpack:layouts}
Android Jetpack umfasst auch mehrere Layout Bibliotheken.
Im Rahmen dieses Projektes wurden \textit{ConstraintLayout} und \textit{SwiperefreshLayout} verwendet.

Komplexe Hierarchien in Benutzeroberflächen verringern deren Performanz bei Layoutänderungen.
ConstraintLayouts ermöglichen das freie Platzieren von Elementen durch Angaben zur Einschränkung ihrer Positionen.
So können Entwickler simplere und effizientere Layouts implementieren.

Bei mobilen Anwendungen gibt es die gängige Geste des Herunterziehens zum Aktualisieren eines Bildschirms.
Mit Hilfe von SwiperefreshLayout ist es möglich diese Funktionalität mit wenigen Zeilen Quelltext zu bestehenden Benutzeroberflächen hinzuzufügen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{RecyclerView}
\label{subsubsec:app:jetpack:recyclerview}
\textit{RecyclerViews} ermöglichen das Anzeigen von scrollbaren, dynamischen Listen.
Anders als primitive \textit{Views} erzeugt RecyclerView nur tatsächlich benötigten Container und verwendet diese wieder.
Dadurch sind RecyclerViews performanter als beispielsweise \textit{ListViews} oder \textit{LinearLayouts}.
Entwickler müssen Adapter verwenden um Daten an eine RecyclerView zu übergeben.
Es stehen jedoch Hilfsklassen bereit, die bereits über einen Großteil der benötigten Logik verfügen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Room}
\label{subsubsec:app:jetpack:room}
Bei \textit{Room} handelt es sich um eine Abstraktionsebene für \textit{SQLite} Datenbanken.
Es können sowohl programmatische als auch reguläre SQL Anfragen definiert werden.
Die Hauptfunktion von Room liegt jedoch in der Möglichkeit Rückgabewerte in reaktiven Wrapper-Klassen, wie beispielsweise LiveData, zu erhalten.
Room übernimmt in diesem Fall die Aktualisierung der Daten, wodurch es reicht Datenbankanfragen einmalig auszuführen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Paging}
\label{subsubsec:app:jetpack:paging}
Das Laden großer Datenmengen aus Datenbanken oder Netzwerkquellen ist ein nicht zu unterschätzender Aufwand.
Die \textit{Paging} Bibliothek ermöglicht deshalb ein stückweises Laden von Datensätzen.
Dazu muss eine \textit{DataSource Factory} vorliegen, welche dieses Konzept unterstützt.
Unter anderem ermöglicht Room solche Factories als Rückgabewerte zu definieren.
Sie lassen sich zu LiveData Objekten transformieren, welche \textit{PagedLists} enthalten.
Diese besonderen Listen lassen sich unter anderem mit RecyclerViews und \textit{PagedListAdaptern} verwenden.
Im Endeffekt können so Performanz und Speicherverbrauch verbessert werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Work}
\label{subsubsec:app:jetpack:work}
Hintergrundaufgaben, wie beispielsweise das Bereinigen von Datenbanken, können über die \textit{Work} Bibliothek verwaltet werden.
Die zu erledigende Arbeit wird dabei in einer \textit{Worker} Klasse definiert.
Bei der Registrierung können optional Einschränkungen angegeben werden, die festlegen wann und unter welchen Umständen der Worker ausgeführt wird.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{KTX}
\label{subsubsec:app:jetpack:extensions}
Kotlin ist die von Google empfohlene Sprache für die Entwicklung von Android Apps \autocite{androidkotlin}.
Eine Vielzahl an Android Jetpack Bibliotheken enthalten Erweiterungsmethoden und Sprachfunktionen, welche die Programmierung von Android Apps mit Kotlin vereinfachen und verbessern.
Dazu zählen unter anderem Methoden zum Erzeugen von ViewModels sowie \textit{Coroutine Scopes} für ViewModels, Erweiterungen für \textit{SharedPreferences} und Unterstützung für \textit{Coroutines} in Android Jetpack Bibliotheken.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Weitere Bibliotheken}
\label{subsec:app:bibs}
Im Rahmen der App-Entwicklung wurden auch Bibliotheken verwendet, welche nicht Teil von Android Jetpack sind.
Im Folgenden werden ihre Funktionen und Verwendungsgründe vorgestellt.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Retrofit und Moshi}
\label{subsubsec:app:bibs:retrofitmoshi}
Über \textit{Retrofit} können abstrakte Methoden zum Anbinden von APIs definiert werden.
Entwickler müssen dazu Informationen über die Art von Anfragen angeben.
Implementierungen dieser Methoden werden von der Bibliothek generiert.
In Kombination mit der Serialisierungs-Bibliothek \textit{Moshi} können so Netzwerkschnittstellen mit geringem Quelltextaufwand angebunden werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Glide}
\label{subsubsec:app:bibs:glide}
\textit{Glide} übernimmt das asynchrone Laden und Darstellen von Bildern.
Dabei lassen sich Einstellungen für Verhalten und Darstellung anpassen.
Unter anderem kann Glide Bilder für schnelleres Laden zwischenspeichern, zuschneiden und während einem Ladevorgang durch Platzhalter ersetzen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Image Picker}
\label{subsubsec:app:bibs:imagepicker}
Die Bibliothek \textit{Image Picker} ermöglicht die Auswahl von Bildern zur Laufzeit, die Nutzer entweder aus ihrer Galerie auswählen oder mit ihrer Kamera aufnehmen können.
Eine äquivalente Funktionalität zu implementieren ist mit nicht-trivialem Aufwand verbunden, weshalb eine Verwendung existierender Bibliotheken die Entwicklung verkürzte.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{PrettyTime}
\label{subsubsec:app:bibs:prettytime}
\textit{PrettyTime} wird verwendet um Zeitstempel in ein für Menschen lesbares Format zu transformieren.
Die Bibliothek unterstützt mehrere Sprachen, unter anderem Deutsch sowie Englisch, und erspart Entwicklern so das Übersetzen und Formatieren.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Timber}
\label{subsubsec:app:bibs:timber}
Bei \textit{Timber} handelt es sich um eine Bibliothek die das Protokollieren vereinfacht, Nachrichten mit zusätzlichen Informationen wie beispielsweise ihrem Ursprung ausgibt und jegliche Protokollierung außerhalb der Entwicklungsphase deaktiviert.
So ist es während der Entwicklung möglich schnell detaillierte Protokollnachrichten zu verfassen, welche bei der Suche nach Fehlern helfen und keine Auswirkung auf ausgelieferte Endprodukte haben.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Konfiguration}
\label{subsec:app:configuration}
Zur Konfiguration muss die Adresse der Serveranwendung angepasst werden.
Dies findet über den Wert des Feldes \verb|KOFFEE_BACKEND_URL|, in der Datei \verb|build.gradle|, statt.
Eine weitere Konfiguration ist nicht notwendig.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Serveranwendung}
\label{sec:backend}
Das Backend wurde, wie auch die App, mit der Programmiersprache Kotlin entwickelt.
Es handelt sich dabei um eine \textit{REST}-Schnittstelle\footnote{Siehe \url{https://restfulapi.net/}.}, die dazu dient den Zustand der digitalen Kaffeekasse zu verwalten.
Die folgenden Abschnitte stellen Funktionalität, Architektur, Authentifizierung, verwendete Bibliotheken sowie Konfiguration und Inbetriebnahme des Backends vor.
%------------------------------------------------------------------------------------------------------------------------------------------------------ 

\subsection{Funktionalität}
\label{subsec:backend:functionality}
Nach erfolgreicher Authentifizierung können Administratoren Nutzer sowie Artikel erstellen, aktualisieren und löschen.
Zudem können Administratoren Guthabenaufladungen durchführen.
Ohne Authentifizierung ist es möglich Artikel zu kaufen und Käufe innerhalb einer Minute zu stornieren.
Zudem können Nutzer Profilbilder hochladen und löschen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Architektur}
\label{subsec:backend:architecture}
Das Backend verwendet eine serviceorientierte Architektur.
Dabei werden Anfragen an Dienste weitergeleitet.
Antworten von Diensten enthalten Informationen über die Ergebnisse von Aktionen, wie Statuscodes, Daten oder Fehlermeldungen, und werden an Kommunikationspartner weitergeleitet.

Es existieren Dienste für Nutzer-, Profilbild-, Artikel- und Transaktionsverwaltung.
Validierung sowie Fehlerbehandlung finden ausschließlich in Diensten statt.
Dafür verwenden sie einen funktionalen Ansatz und sind selbst zustandslos.

Analog zur Android App liegt die Persistenzebene in Form von Repositories vor.
Die gegebenen Implementierungen der Nutzer-, Profilbild- und Artikel-Repositories fungieren als Schnittstellen zur verwendeten \textit{MongoDB}.

Sowohl Dienste als auch Repositories liegen als \textit{Interfaces} und Implementierungen vor, um separates Testen zu ermöglichen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Authentifizierung}
\label{subsec:backend:authentication}
Um Administrator-Funktionen zu verwenden müssen sich Nutzer authentifizieren.
Dies findet mit Hilfe von \textit{JSON Web Tokens}\footnote{Siehe \url{https://jwt.io/}.}, auch \textit{JWT} genannt, statt.
Ein JWT wird nach einem erfolgreichen Login generiert, ist für 24 Stunden gültig und muss bei jeder Anfrage für Administrator-Funktionen enthalten sein.
Einloggen können sich nur Nutzer, die über Administratorrechte verfügen, welche wiederum nur von Administratoren vergeben werden können.
Während jedem Start generiert das Backend einen Standard\-administrator, welcher zuvor festgelegte Daten besitzt (siehe \autoref{subsec:backend:configuration}).
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Datenbank}
\label{subsec:backend:database}
Bei der MongoDB des Backends handelt es sich um eine dokumentenbasierte Datenbank.
Die von ihr verwendete Schemas entsprechen deshalb denen der im Quelltext definierten Klassen (siehe \nameref{subsec:attachments:schemas}).
Falls die über Docker Compose vorkonfigurierte MongoDB verwendet wird, lassen sich Daten mit Hilfe zweier Kommandozeilenbefehle sichern und wiederherstellen (siehe \nameref{subsec:attachments:database}).
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Bibliotheken}
\label{subsec:backend:bibs}
Um die Entwicklung des Backends zu beschleunigen wurden mehrere Open Source Bibliotheken verwendet.
Diese werden im Folgenden kurz vorgestellt.
Zusätzliche Informationen können den jeweiligen Projektseiten entnommen werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Ktor}
\label{subsubsec:backend:bibs:ktor}
\textit{Ktor}, ein \textit{Web Framework} vom Entwickler der Sprache Kotlin, bildet die Grundlage des Backends.
Ktor verwendet eine \textit{Domain Specific Language}, auch \textit{DSL} genannt, zum Definieren von Modulen.
Solche Module können in der Serveranwendung installiert werden um ein erwünschtes Verhalten zu erreichen.
Ktor selbst stellt dabei Module für verschiedene Bereiche, wie unter anderem Protokollierung, Serialisierung und Authentifizierung, zur Verfügung.
Auch vordefinierte Module können im Quelltext angepasst werden.
Ktor zeichnet sich zudem dadurch aus, dass es vollständig asynchron arbeitet und Kotlin Coroutines an allen Stellen der Konfiguration verwendbar sind.
Dadurch können Entwickler asynchronen und performanten Quelltext schreiben, ohne zusätzliche Sprachkonstrukte zu verwenden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Koin}
\label{subsubsec:backend:bibs:koin}
\textit{Koin} ist ein Framework für \textit{Dependency Injection}, mit dem einzelne Komponenten des Servers unabhängig von ihrem Einsatzort initialisiert werden können.
So ist es möglich Instanzen von Diensten sowie Repositories wiederzuverwenden und den für Instanziierung benötigten Quelltext zu minimieren.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{KMongo}
\label{subsubsec:backend:bibs:kmongo}
Die \textit{KMongo} Bibliothek ermöglicht eine simple Verwendung von \textit{Mongo}-Datenbanken in Kotlin.
Dies erreicht sie durch automatische Serialisierung, Unterstützung für Kotlin Coroutines und programmatische, typsichere Anfragen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{jBCrypt}
\label{subsubsec:backend:bibs:jbcrypt}
Das Backend muss Passwörter sicher in der Datenbank ablegen.
Dafür müssen diese mit einer geeigneten \textit{Hash}-Funktion transformiert werden.
Die Bibliothek \textit{jBCrypt} enthält solche Funktionen.
Darüber hinaus ermöglicht sie auch das anschließende Überprüfen von Passwörtern.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Arkenv}
\label{subsubsec:backend:bibs:arkenv}
Zur Konfiguration des Backends an eine Einsatzumgebung müssen einige Parameter, wie die Adresse der Datenbank, gesetzt werden.
\textit{Arkenv} erlaubt es diese Umgebungsvariablen programmatisch und typsicher zu definieren, so dass die Fehleranfälligkeit beim Einlesen reduziert wird.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Docker Secrets}
\label{subsubsec:backend:bibs:dockersecrets}
Neben Umgebungsvariablen müssen auch sensible Daten, wie die Zugangsinformationen des Standardadministrators, festgelegt werden.
Um diese zu schützen werden beim \textit{Deployment} des Backends mit Docker sogenannte \textit{Secrets} verwendet, welche nur das Backend selbst einsehen kann.
Da es sich dabei um Dateien handelt ist das Einlesen ihrer Informationen mit einer Syntaxanalyse verbunden.
Die leichtgewichtige Bibliothek \textit{Docker Secrets} übernimmt diesen Aufwand und lädt Parameter von Dateien in \textit{Maps}.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Konfiguration und Inbetriebnahme}
\label{subsec:backend:configuration}
Um das Backend an Einsatzumgebungen anzupassen sollten einige Parameter konfiguriert werden.
Dies findet über \verb|.env|-Dateien statt, welche sich in dem \verb|environments|-Ordner des Hauptverzeichnisses befinden.
Dort werden die Adressen von Server und Datenbank sowie Eigenschaften der Zertifizierung festgelegt.
Darüber hinaus wird der Namen des Docker Secrets angegeben, in welchem sensible Daten hinterlegt werden.
Bei der Standardkonfiguration muss sich diese Datei im \verb|secrets|-Verzeichnis befinden.
\verb|koffee.secret| enthält den zur Signierung von JWTs verwendeten Schlüssel sowie Informationen des Standardadministratoren.
Das folgende Beispiel zeigt eine mögliche Konfiguration dieser Datei.
\begin{lstlisting}[style=simpleListing, title={Beispielinhalt von /secrets/koffee.secret}]
ID=admin
NAME=Admin
PASSWORD=adminPassword
HMAC_SECRET=geheimeZeichenkette
\end{lstlisting}
Um das Backend in Betrieb zu nehmen müssen zuerst der \verb|URL|-Parameter in der Datei \verb|domain.env| angepasst und die \verb|.secret|-Datei angelegt werden.
Nachdem das Projekt mit dem Befehl \verb|./gradlew build| erzeugt wurde, kann die Serveranwendung über Docker Compose gestartet werden.
Schrittweise Anleitungen zur Inbetriebnahme befinden sich im Anhang (siehe \nameref{subsec:attachments:instructions}).
%------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Vorgehen und Entstehungsprozess}
\label{sec:methodologies}
Die Projektarbeit begann mit der Entwicklung des Backends.
Zunächst wurden Aufbau sowie Struktur festgelegt und implementiert um eine Arbeitsgrundlage zu schaffen.
Dank der modularen Zusammensetzung des Backends war es möglich die benötigten Endpunkte für Nutzer, Artikel sowie Transaktionen schnell und unabhängig voneinander zu implementieren.
Anschließend wurde die Authentifizierung hinzugefügt um Endpunkte vor unautorisierten Zugriffen zu schützen.
Da eine langfristige Nutzung des Backends in Frage kam, wurde der Quelltext nahezu vollständig getestet.
Tests wurden parallel zum eigentlich Programm geschrieben um Fehler schnell zu erkennen.
Im Laufe der Entwicklung wurde das Backend mehrfach überarbeitet um einen möglichst funktionalen Programmierstil zu erreichen.
So konnten Lesbarkeit des Quelltextes verbessert und Fehleranfälligkeit reduziert werden.
Während der gesamten Projektarbeit wurde zudem die Formatierung des Quelltextes mit dem Tool \textit{klint}\footnote{Siehe \url{https://github.com/pinterest/ktlint}.} kontrolliert und korrigiert.
Darüber hinaus wurden Open Source Bibliotheken verwendet, falls Problemlösungen einen größeren Aufwand erforderten.
Dadurch konnte die Entwicklungszeit verkürzt und auf die eigentliche Aufgabenstellung fokussiert werden.

Die Entwicklung der App begann Ende April.
Analog zu den Endpunkten des Backends wurden die Bildschirme der App nacheinander implementiert, wobei jeweils mehrere Revisionen durchgeführt wurden.
Eine Verwendung der Android Jetpack Bibliotheken erlaubten dabei eine schnelle Entwicklung mit einem geringen Anteil an Boilerplate Code.
Um diesen weiter zu reduzieren wurden im Laufe der Entwicklung häufig auftretende Muster, wie beispielsweise von ViewModels initiierte Aktionen, in Klassen ausgelagert.
Auch bei den ViewModels selbst sowie Fragmenten wurde Vererbung verwendet um oft benötigtes Verhalten nicht mehrfach zu implementieren.
Zudem wurde die Fehlerbehandlung zentralisiert um die Fehlerausgabe zu vereinfachen und Abstürze zu verhindern.
Durch solche Änderungen war es möglich den Quelltext deutlich zu kürzen.

Zunächst wurde die App für einen Nutzer pro Endgerät entwickelt.
Anfang Juni wurde, nach Anfrage des Projektbetreuers, ein zusätzlicher Modus für mehrere Nutzer implementiert.
Weil die einzelnen Komponenten der App bereits modular und wiederverwendbar waren, konnte diese größere Änderung schnell umgesetzt werden. 
Im Anschluss wurden ein Großteil der Benutzeroberflächen sowie deren Verwendung überarbeitet und verbessert.

Nachdem die Funktionalität beider Teilprojekte vollständig implementiert war, wurde mit der Dokumentation des Quelltextes begonnen, welche im Internet abrufbar ist\footnote{Siehe \url{http://koffee-app.yeger.eu/} und \url{http://koffee-backend.yeger.eu/}.}.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Ergebnisse}
\label{sec:results}
Alle Grundfunktionen des Kaffeekassensystem wurden sowohl in der App als auch im Backend umgesetzt.
Dazu gehört das administrative Verwalten von Artikeln und Nutzern sowie Kaufen und Stornieren.
Zusätzlich wurde ein alternativer Modus für eine geteilte Verwendung durch mehrere Nutzer in der App implementiert.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Fazit}
\label{sec:conclusion}
Die Vorzüge der Android Jetpack Bibliotheken zeigten sich bereits während der Entwicklung.
Mit Fragmenten und ViewModels war es möglich neue Bildschirme schnell zu implementieren.
Zudem ermöglichten Android Jetpacks visuelle Navigationsgraphen ein einfaches und übersichtliches Verknüpfen von Fragmenten.
Der dadurch gewonnene Gesamtüberblick resultierte in einer sicheren und fehlerresistenten Struktur.
Der automatisierte Lebenszyklus vieler Jetpack Komponenten erlaubte zudem eine Minimierung an Interaktionen mit dem Android Framework.
Stattdessen war es möglich den Fokus auf das Verhalten von Benutzeroberflächen und Geschäftslogik zu legen.
Des Weiteren hat sich Room als eine der wichtigsten Komponenten von Android Jetpack erwiesen.
Bei der Entwicklung trivialisierte sie Datenbankzugriffe und reduzierte Datenverwaltung auf ein Minimum.
Sichtbar wurden diese Vorzüge besonders bei der Entwicklungszeit.
Meilensteine wurden meist Wochen zuvor erreicht, wodurch zusätzliche Funktionen implementiert werden konnten.

Auch bei Verwendung der App sind Vorzüge der Jetpack Bibliotheken erkennbar.
Die Asynchronität der Kombination von Room, LiveData und ViewModels stellt sicher, dass Datenbankzugriffe nicht zu einer Blockierung der Benutzeroberfläche führen.
RecyclerViews sorgen zudem für eine performante Darstellung von Listen und ermöglichen flüssiges Scrollen durch diese.
Die Paging Bibliothek begünstigt dies weiter.
Sie sorgt dafür, dass das Laden von Listen aus der Datenbank auch bei vielen Einträgen nicht langsamer wird.
Lifecycle Komponenten sorgen zudem dafür, dass sie nicht länger als benötigt aktiv bleiben, wodurch Speicher- sowie Prozessorverbrauch reduziert werden.

Mit Android Jetpack Bibliotheken entwickelte Apps sind zwar nicht zwingend schneller oder besser als Herkömmliche, jedoch ist es für Entwickler einfacher diese Ziele zu erreichen, da Grundbausteine und Architektur bereits gegeben sind.
Weil sie zugleich eine beschleunigte Entwicklung ermöglichen und die Zukunft der von Google entwickelten Android Bibliotheken bilden, ist es empfehlenswert bei der App Entwicklung auf Jetpack Komponenten zurückzugreifen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\newpage
\begingroup
\raggedright
\printbibliography[title={Referenzen}, keyword=citations]
\nocite{*}
\newrefcontext[sorting=nty]
\printbibliography[title={Dokumentationen}, keyword=sources, env=sources]
\endgroup

\newpage
\section*{Anhang}
\markboth{Anhang}{Anhang}
\label{sec:attachments}

\subsection*{Inbetriebnahme der Serveranwendung}
\label{subsec:attachments:instructions}

\subsubsection*{Einsatz während der Entwicklung}
\label{subsubsec:attachments:instructions:development}
\begin{enumerate}
	\item \verb|./gradlew build|
	\item Das benötigte Docker Secret anlegen (siehe \autoref{subsec:backend:configuration}).
	\item \verb|docker-compose up --build -d|
	\item Der Server ist nun unter \verb|http://localhost:8080| erreichbar.
\end{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection*{Einsatz in der Produktion}
\label{subsubsec:attachments:instructions:production}
\begin{enumerate}
	\item \verb|./gradlew build|
	\item Das benötigte Docker Secret anlegen (siehe \autoref{subsec:backend:configuration}).
	\item Den Wert von \verb|URL| in \verb|./environments/domain.env| auf eine valide Domäne ändern, über welche die Host-Maschine erreichbar ist.
	\item Sicherstellen, dass die Host-Maschine über die Ports 80 und 443 erreichbar ist.
	\item \verb|docker-compose -f docker-compose-prod.yml up --build -d|
	\item Der Server ist nun unter \verb|https://your.domain/koffee| erreichbar.
\end{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection*{Datenbankverwaltung}
\label{subsec:attachments:database}

\subsubsection*{Datensicherung}
\label{subsubsec:attachments:database:backup}
\begin{lstlisting}[language=Bash, breaklines=true]
$ docker-compose exec -T mongo mongodump --archive --gzip --db koffee-database > dump.gz
\end{lstlisting}
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection*{Datenwiederherstellung}
\label{subsubsec:attachments:database:restore}
\begin{lstlisting}[language=Bash, breaklines=true]
$ docker-compose exec -T mongo mongorestore --archive --gzip < dump.gz
\end{lstlisting}
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection*{Datenbankschemas}
\label{subsec:attachments:schemas}

\subsubsection*{User}
\label{subsubsec:attachments:schemas:user}
\begin{table}[H]
	\centering
	\begin{tabular}{@{}lll@{}}
		Feld         & Typ                                      & Anmerkung             \\ \toprule
		id           & String                                   & Muss einzigartig sein \\ \midrule
		name         & String                                   &                       \\ \midrule
		isAdmin      & Boolean                                  & Erlaubt Authentifizierung \\ \midrule
		password     & String                                   & Optional              \\ \midrule
		transactions & List\textless{}Transaction\textgreater{} & Verwendet Polymorphie \\ \bottomrule
	\end{tabular}
	\label{tab:attachments:schemas:user}
\end{table}

\subsubsection*{Profile Image}
\label{subsubsec:attachments:schemas:profileimage}
\begin{table}[H]
	\centering
	\begin{tabular}{@{}lll@{}}
		Feld         & Typ    & Anmerkung                      \\ \toprule
		id           & String & Muss einer User-ID entsprechen \\ \midrule
		encodedImage & String & Base64-Kodierung               \\ \midrule
		timestamp    & Long   &                                \\ \bottomrule
	\end{tabular}
	\label{tab:attachments:schemas:profileimage}
\end{table}

\subsubsection*{Item}
\label{subsubsec:attachments:schemas:item}
\begin{table}[H]
	\centering
	\begin{tabular}{@{}lll@{}}
		Feld   & Typ    & Anmerkung             \\ \toprule
		id     & String & Muss einzigartig sein \\ \midrule
		name   & String &                       \\ \midrule
		amount & Int    & Optional              \\ \midrule
		price  & Double &                       \\ \bottomrule
	\end{tabular}
	\label{tab:attachments:schemas:item}
\end{table}

\subsubsection*{Transaction - Funding}
\label{subsubsec:attachments:schemas:funding}
\begin{table}[H]
	\centering
	\begin{tabular}{@{}lll@{}}
		Feld      & Typ    & Anmerkung                      \\ \toprule
		type      & String & Muss \glqq funding\grqq{} sein \\ \midrule
		value     & Double & Wert der Guthabenaufladung     \\ \midrule
		timestamp & Long   &                                \\ \bottomrule
	\end{tabular}
	\label{tab:attachments:schemas:funding}
\end{table}

\subsubsection*{Transaction - Purchase}
\label{subsubsec:attachments:schemas:purchase}
\begin{table}[H]
	\centering
	\begin{tabular}{@{}lll@{}}
		Feld      & Typ    & Anmerkung                       \\ \toprule
		type      & String & Muss \glqq purchase\grqq{} sein \\ \midrule
		value     & Double & Gesamtwert der Transaktion      \\ \midrule
		timestamp & Long   &                                 \\ \midrule
		itemId    & String &                                 \\ \midrule
		itemName  & String &                                 \\ \midrule
		amount    & Int    &                                 \\ \bottomrule
	\end{tabular}
	\label{tab:attachments:schemas:purchase}
\end{table}

\subsubsection*{Transaction - Refund}
\label{subsubsec:attachments:schemas:refund}
\begin{table}[H]
	\centering
	\begin{tabular}{@{}lll@{}}
		Feld      & Typ    & Anmerkung                     \\ \toprule
		type      & String & Muss \glqq refund\grqq{} sein \\ \midrule
		value     & Double & Gesamtwert der Transaktion    \\ \midrule
		timestamp & Long   &                               \\ \midrule
		itemId    & String &                               \\ \midrule
		itemName  & String &                               \\ \midrule
		amount    & Int    &                               \\ \bottomrule
	\end{tabular}
	\label{tab:attachments:schemas:refund}
\end{table}
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection*{Routen}
\label{subsec:attachments:routes}

Alle Routen verwenden JSON um Daten zu senden und erhalten.
Routen, welche eine zuvorige Authentifizierung voraussetzen, sind mit einem Sternchen (\verb|*|) gekennzeichnet.
Es werden keine \textit{Query}-Parameter verwendet.
Felder eventuell benötigter \textit{Body}-Parameter sind unter den jeweiligen Routen aufgelistet.

\begin{description}
	\item[POST /login] Authentifiziert einen Nutzer und gibt im Erfolgsfall einen JWT zurück.
	\begin{itemize}
		\item id: String
		\item password: String
	\end{itemize}

	\item[GET /users] Gibt IDs und Namen aller Nutzer zurück.
	
	\item[*POST /users] Erstellt einen neuen Nutzer und gibt dessen ID zurück.
	\begin{itemize}
		\item id: String (Optional)
		\item name: String
		\item isAdmin: Boolean
		\item password: String (Optional)
	\end{itemize}

	\item[*PUT /users] Aktualisiert einen existierenden Nutzer.
	\begin{itemize}
		\item id: String
		\item name: String
		\item isAdmin: Boolean
		\item password: String (Optional)
	\end{itemize}

	\item[GET /users/:id] Gibt ID, Name und Guthaben des Nutzers mit der gegebenen ID zurück.
	
	\item[*DELETE /users/:id] Löscht den Nutzer mit der gegebenen ID.
	
	\item[*POST /users/:id/funding] Lädt das Guthaben des Nutzers mit der gegebenen ID um den gewünschten Betrag auf.
	\begin{itemize}
		\item amount: Double
	\end{itemize}

	\item[POST /users/:id/purchases] Kauft einen Artikel für den Nutzer mit der gegebenen ID.
	\begin{itemize}
		\item itemId: String
		\item amount: Int
	\end{itemize}

	\item[POST /users/:id/purchases/refund] Falls möglich wird der letzte Kauf des Nutzers mit der gegebenen ID storniert.
	
	\item[GET /users/:id/image] Gibt Bytes des Profilbilds eines Nutzers mit der gegebenen ID zurück.
	
	\item[GET /users/:id/image/timestamp] Antwortet mit dem Zeitstempel des Profilbilds eines Nutzers mit der gegebenen ID.
	
	\item[POST /users/:id/image] Speichert die hochgeladene Datei als Profilbild des Nutzers mit der gegebenen ID.
	\begin{itemize}
		\item Multipart Datei (kein JSON)
	\end{itemize}

	\item[DELETE /users/:id/image] Löscht das Profilbilds des Nutzers mit der gegebenen ID.
	
	
	\item[GET /items] Gibt IDs, Namen, Preise und Mengenangaben aller Artikel zurück.

	\item[*POST /items] Erstellt einen neuen Artikel und gibt dessen ID zurück.
	\begin{itemize}
		\item id: String (Optional)
		\item name: String
		\item amount: Int (Optional)
		\item price: Double
	\end{itemize}
	
	\item[*PUT /items] Aktualisiert einen existierenden Artikel.
	\begin{itemize}
		\item id: String
		\item name: String
		\item amount: Int (Optional)
		\item price: Double
	\end{itemize}
	
	\item[GET /items/:id] Gibt ID, Name, Preis und Mengenangabe des Artikels mit der gegebenen ID zurück.
	
	\item[*DELETE /users/:id] Löscht den Artikel mit der gegebenen ID.
\end{description}
%------------------------------------------------------------------------------------------------------------------------------------------------------

\end{document}
