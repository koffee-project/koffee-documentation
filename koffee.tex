\documentclass[a4paper, 11pt]{article}

\usepackage[%
backend = biber,
sortlocale=de_DE,
natbib=true,
style = numeric,
autocite = superscript
]{biblatex}
\addbibresource{references.bib}
\DeclareCiteCommand{\supercite}[\mkbibsuperscript]{}
{\bibopenbracket%
	\usebibmacro{citeindex}%
	\usebibmacro{cite}%
	\usebibmacro{postnote}%
	\bibclosebracket}
{\supercitedelim}
{}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\sectionmark}[1]{\markboth{#1}{}}
\fancyhead[ER]{\rightmark}
\fancyhead[OL]{\nouppercase{\leftmark}}
\cfoot{\thepage}

\usepackage{float}
\newfloat{lstfloat}{htb}{lop}

\usepackage[ngerman]{isodate, babel}

\usepackage{hyperref}
\addto\extrasngerman{
	\renewcommand{\sectionautorefname}{Kapitel}
	\renewcommand{\subsectionautorefname}{Abschnitt}
	\renewcommand{\subsubsectionautorefname}{Unterabschnitt}
}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\overfullrule=1mm

%opening
\title{Dokumentation zur Projektarbeit digitale Kaffeekasse}
\author{Jan Müller}
\date{\today}

\begin{document}

\maketitle

\section{Einleitung}
\label{sec:intro}
Die Entwicklung von Android Apps zeichnet sich unter anderem dadurch aus, dass die \textit{API Level}\footnote{Zum Zeitpunkt dieser Ausarbeitung existieren 29 API Level.} des \textit{Android Frameworks} zum Teil unterschiedlich behandelt werden müssen.
Die Versionsverteilung bei Android erstreckt sich über mehrere Versionen\footnote{https://www.bidouille.org/misc/androidcharts}.
Zur Maximierung der potenziellen Nutzer ist es entsprechend notwendig auch ältere API Level zu unterstützen.
Damit Entwickler dort ebenfalls neue Funktionen verwenden können, wurden die \textit{Support Libraries}\footnote{https://developer.android.com/topic/libraries/support-library} eingeführt.
Aus diesen entwickelten sich die \textit{Android Jetpack}\footnote{https://developer.android.com/jetpack/androidx} Bibliotheken.

Ziel dieses Projektes war die Entwicklung einer Kaffeekassen App und einer dazugehörigen Serveranwendung mit der Programmiersprache Kotlin.
Bei der Entwicklung der App sollten Android Jetpack Bibliotheken verwendet und mit bisherigen Methoden verglichen werden.
Zuerst wurde jedoch die Serveranwendung, das sogenannte \textit{Backend}, entwickelt.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Android App}
\label{sec:app}

\subsection{Architektur}
\label{subsec:app:architecture}
%TODO Bild
Die App verwendet die von Google empfohlene Architektur\footnote{https://developer.android.com/jetpack/guide}.
Fragmente, also Teile der Benutzeroberfläche, verwenden \textit{ViewModels} um Daten zu beziehen und auf \textit{Business Logic} zuzugreifen.
ViewModels greifen auf wiederum auf \textit{Repositories} zu, die als \textit{Single source of truth} dienen.
Das heißt der Zustand von Datenmodellen wird ausschließlich von Repositories festgelegt, wodurch inkonsistente Datenbestände vermieden werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Android Jetpack}
\label{subsec:app:jetpack}
Im Folgenden werden die verwendeten Android Jetpack Bibliotheken kurz vorgestellt. Detaillierte Informationen können der offiziellen Dokumentation entnommen werden\footnote{https://developer.android.com/jetpack/androidx/explorer}.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Core und AppCompat}
\label{subsubsec:app:jetpack:base}
Die \textit{Core} und \textit{AppCompat} Bibliotheken ermöglichen eine Verwendung von Funktionen neuer Android API Levels auf älteren Android Versionen.
Dazu stellen sie eine Vielzahl an Hilfsklassen zur Verfügung, welche die unterschiedliche Behandlung der API Levels verkapseln und die Entwicklung so vereinheitlichen und vereinfachen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Fragment}
\label{subsubsec:app:jetpack:fragment}
Fragmente sind modulare Teile einer Benutzeroberfläche.
Sie sind wiederverwendbar, leichtgewichtig und lassen sich in \textit{Activities} sowie anderen Fragmenten kombinieren um komplexe Benutzeroberflächen zu erstellen.
Ihr Lebenszyklus wird von ihrem Container gesteuert. %TODO change
Darüber hinaus ist es möglich Fragmente zur Laufzeit hinzuzufügen und zu entfernen.
Komplexe \textit{Layouts} lassen sich so in mehrere Fragmente unterteilen. %TODO change
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Databinding}
\label{subsubsec:app:jetpack:databinding}
Mit Hilfe der \textit{Databinding} Bibliothek ist es möglich Datenquellen für Eigenschaften von Benutzeroberflächen und deren Elemente in Layout-Dateien festzulegen.
In Kombination mit \textit{LiveData} passen sich Benutzeroberflächen bei Änderungen automatisch an, wodurch der Anteil an Quelltext für Benutzeroberflächen reduziert wird.
Zusätzlich lassen sich \textit{BindingAdapters} definieren, durch welche benutzerdefiniertes Verhalten und eine Definition neuer Eigenschaften möglich wird.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Lifecycle}
\label{subsubsec:app:jetpack:lifecycle}
Die \textit{Lifecycle} Bibliothek umfasst primär ViewModels und LiveData.
Bei ViewModels handelt es sich um Klassen, die von Fragmenten zur Darstellung von Daten und Interaktion mit Business Logic verwendet werden.
Ihre Erzeugung wird von Framework-Methoden übernommen.
Diese stellen sicher, dass ViewModels sich dem Lebenszyklus des besitzenden Fragments anpassen und wiederverwendet werden können.

LiveData baut auf diesem Konzept auf.
Dabei handelt es sich um \textit{Wrapper} für beliebige Daten, deren Werte beobachtet werden können.
Anders als traditionelle \textit{Observables} besitzt LiveData jedoch einen Lebenszyklus.
Änderungen werden nur dann propagiert, wenn sie auch beobachtet.
Zudem übernimmt das besitzende ViewModel die Verwaltung ihres Lebenszyklus, wodurch \textit{Leaks} vermieden werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Navigation}
\label{subsubsec:app:jetpack:navigation}
Fragmente können mit Argumenten erzeugt werden.
Dabei ist jedoch keine Typsicherheit garantiert und es gibt keinen Mechanismus, der die Vollständigkeit von Argumenten sicherstellt.
Die \textit{Navigation} Bibliothek löst beide Probleme durch Verwendung von Navigationsgraphen.
In diesen werden die verfügbaren Fragmente sowie ihre Argumente definiert.
Durch Verbindungen zwischen Fragmenten werden \textit{Directions} angegeben.
Deren Verwendung stellst sicher, dass alle Argumente mit korrektem Typ festgelegt wurden und Navigation nur zu korrekten Fragmenten möglich ist.
Darüber hinaus unterstützt die Bibliothek Navigationscontroller, die das Initialisieren von Benutzerelemente wie beispielsweise einer \textit{Bottom Navigation} übernehmen. 
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{ContsraintLayout und SwiperefreshLayout}
\label{subsubsec:app:jetpack:layouts}

\subsubsection{RecyclerView}
\label{subsubsec:app:jetpack:recyclerview}
\textit{RecyclerViews} ermöglichen das Anzeigen von scrollbaren, dynamischen Listen.
Anders als primitive \textit{Views} erzeugt RecyclerView nur die tatsächlich benötigten Container und verwendet diese wieder.
Dies ist performanter als beispielsweise eine \textit{ListView}.
Entwickler müssen Adapter verwenden um Daten an eine RecyclerView zu übergeben.

\subsubsection{Room}
\label{subsubsec:app:jetpack:room}
Bei \textit{Room} handelt es sich um eine Abstraktionsebene für \textit{SQLite} Datenbanken.
Es können sowohl programmatische als auch reguläre SQL Anfragen definiert werden.
Die Hauptfunktion von Room liegt jedoch in der Möglichkeit Rückgabewerte in reaktiven Wrapper-Klassen, wie beispielsweise LiveData, zu erhalten.
Room übernimmt in diesem Fall die Aktualisierung der Daten, wodurch es reicht Datenbankanfragen einmalig auszuführen.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Paging}
\label{subsubsec:app:jetpack:paging}
Das Laden großer Datenmengen aus Datenbanken oder Netzwerkquellen ist ein nicht zu unterschätzender Aufwand.
Die \textit{Paging} Bibliothek ermöglicht deshalb das Laden von kleinen Teilen größerer Datensätze.
Dazu muss eine \textit{DataSource Factory} vorliegen, die das stückweise Laden von Daten unterstützt.
Unter anderem ermöglicht Room solche Factories als Rückgabewerte zu erhalten.
Factories lassen sich zu LiveData Objekten transformieren, die \textit{PagedLists} enthalten.
Diese besonderen Listen können beispielsweise von für RecyclerView mit Hilfe eines \textit{PagedListAdapters} verwendet werden.
Im Endeffekt können so Performanz und Speicherverbrauch verbessert werden.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Work}
\label{subsubsec:app:jetpack:work}

\subsubsection{Erweiterungen}
\label{subsubsec:app:jetpack:extensions}

\section{Serveranwendung}
\label{sec:backend}

\subsection{Architektur}
\label{subsec:backend:architecture}

\subsection{Endpunkte}
\label{subsec:backend:endpoints}

\subsection{Authentifizierung}
\label{subsec:backend:authentication}

\section{Fazit}
\label{sec:conclusion}
%TODO italics
Die Verwendung von Android Jetpack Bibliotheken im Zusammenspiel mit Kotlin vereinfacht die Entwicklung robuster und performanter Android Apps deutlich.
Besonders die automatisierten Lebenszyklen von ViewModel und LiveData helfen bei der Vermeidung Leaks.
%------------------------------------------------------------------------------------------------------------------------------------------------------

\end{document}
